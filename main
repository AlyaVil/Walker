const BMW_TYPE_HUMAN = 0;
const BMW_TYPE_CAT = 1;
const BMW_TYPE_PIGEON = 2;
const BMW_TYPE_BOX = 3; // (for debug)

class BMWalker {
  // Constructor
  constructor(type = BMW_TYPE_HUMAN) {
    // External variables
    // Boundary values
    this.maxSpeed = 2.0;
    this.minSpeed = -2.0;
    this.maxBodyStructure = 6.0; // Type A
    this.minBodyStructure = -6.0; // Type B
    this.maxWeight = 6.0; // Heavy
    this.minWeight = -6.0; // Light
    this.maxNervousness = 6.0; // Nervous
    this.minNervousness = -6.0; // Relaxed
    this.maxHappiness = 6.0; // Happy
    this.minHappiness = -6.0; // Sad

    // Internal variables
    this.type = type;

    this.tm = new BMWTimer();
    this.starttime = this.tm.getTimer();

    this.mtrx = new BMWMatrix();

    // Walker Parameters
    this.speed = 1.0;
    this.bodyStructure = 0;
    this.weight = 0;
    this.nervousness = 0;
    this.happiness = 0;

    // Camera Parameters
    this.azimuth = 0; // rad
    this.angularVelocity = 0; // rad/sec
    this.elevation = 0; // rad
    this.roll = 0; // rad

    // Translation Parameters
    this.flagTranslation = false;
    this.translation_pos = 0;

    this.walker_size = 10;

    // 35 is the exactly correct ratio but need offsetY in this case.
    this.walkerHeightRatio = 40;
    //graphical stuff
    this.motion_vertical_scale = 1;
    this.motion_horizontal_scale = 1;
    this.structure_vertical_scale = 1;
    this.structure_horizontal_scale = 1;

    // Each data
    const walkerData = new BMWData();
    this.meanwalker = walkerData.meanwalker;
    this.bodyStructureaxis = walkerData.bodyStructureaxis;
    this.weightaxis = walkerData.weightaxis;
    this.nervousaxis = walkerData.nervousaxis;
    this.happyaxis = walkerData.happyaxis;
 //camera variables
    this.camera_distance = 1000;

    this.walker_rot_xaxis = 0;
    this.walker_rot_yaxis = 0;
    this.walker_rot_zaxis = 0;

    this.walker_translation_speed = 0;

    this.walkerxmin = 0;
    this.walkerymin = 0;
    this.walkerzmin = 0;
    this.walkerxmax = 0;
    this.walkerymax = 0;
    this.walkerzmax = 0;
    this.walkerxoff = 0;
    this.walkeryoff = 0;
    this.walkerzoff = 0;
    this.walkersizefactor = 0;

    this.axisrot = 0;
    this.nummarkers = 0;

    this.markers = [];
    this.vectors = [];

    this.init();
  }
  
  getVectors(_scale = 1){
    let vs = [];
    // ここでマイナスにしちゃう
    for(let v of this.vectors){
      vs.push({x:v.x * _scale, y:-v.y * _scale, z:v.z * _scale});
    }
    return vs;
  }

  // API: Get markers
  getMarkers(walkerHeight, tmsec = undefined) {
    const markers = []; // return value
    this.vectors = [];

    this.walker_size = walkerHeight / this.walkerHeightRatio;

    if (tmsec === undefined) {
      tmsec = this.tm.getTimer() - this.starttime;
    }
    // console.log(tmsec);
    }
    // Translation calculation
    if (this.flagTranslation && this.type === BMW_TYPE_HUMAN) {
      this.translation_pos = Math.round((this.getTranslationSpeed() * 120 * tmsec) / 1000);
    } else {
      this.translation_pos = 0;
    }

    // Calculate marker positions
    for (i = 0; i < this.nummarkers * 3 + 1; i++) {
      this.markers[i] = this.sample(i, walkertime, true);
    }

    let matrix = this.mtrx.rotateaxis(
      -this.axisrot,
      this.walker_rot_xaxis,
      this.walker_rot_yaxis,
      this.walker_rot_zaxis
    );

    matrix = this.mtrx.multmatrix(this.mtrx.translate(this.translation_pos, 0, 0), matrix);

    const angularVelocity = this.flagTranslation ? 0 : this.angularVelocity;
    matrix = this.mtrx.multmatrix(
      this.mtrx.rotateaxis(this.azimuth + (tmsec * angularVelocity) / 1000, 0, 0, 1),
      matrix
    );

    matrix = this.mtrx.multmatrix(this.mtrx.rotateY(this.elevation), matrix);
    matrix = this.mtrx.multmatrix(this.mtrx.rotateX(this.roll), matrix);

    for (i = 0; i < this.nummarkers; i++) {
      const vector = new Array(4);
      vector[0] = this.markers[i] + this.walkerxoff;
      vector[1] =
        this.markers[i + this.nummarkers] + this.walkeryoff * this.structure_vertical_scale;
      vector[2] = this.markers[i + this.nummarkers * 2] + this.walkerzoff;
      vector[3] = 1;
      
      this.vectors.push({x:vector[0], y:vector[1], z:vector[2]});

      const v2 = this.mtrx.multmatrixvector(matrix, vector);
      v2[0] -= this.camera_distance;
      v2[3] = 1;

      //nudge up
      const pixelsperdegree = 37;
      const xpos = (v2[1] / this.walkersizefactor) * this.walker_size * pixelsperdegree;
      const ypos = -(v2[2] / this.walkersizefactor) * this.walker_size * pixelsperdegree;
      // console.log(xpos, ypos);

 const descs = [
        'Head',
        'Clavicles',
        'L-Shoulder',
        'L-Elbow',
        'L-Hand',
        'R-Shoulder',
        'R-Elbow',
        'R-Hand',
        'Belly',
        'L-Hip',
        'L-Knee',
        'L-Ankle',
        'R-Hip',
        'R-Knee',
        'R-Ankle',
      ];
      markers.push({ x: xpos, y: ypos, desc: descs[i] });
    }

    return markers;
  }

  // API: Get markers that make up the line.
  getLineMarkers(walkerHeight, tmsec = undefined) {
    const markers = this.getMarkers(walkerHeight, tmsec);
    const lineMarkers = [];
    let idxsArray = [];
    if(this.type == 0){
    idxsArray.push(...[
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 4],
      [1, 5],
      [5, 6],
      [6, 7],
      [1, 8],
      [8, 9],
      [9, 10],
      [10, 11],
      [8, 12],
      [12, 13],
      [13, 14],
    ]);}else if(this.type == 1){
      idxsArray.push(...[[0,1],[1,2],[15,16],[16,17],[12,13],[13,14],[5,6],[6,7],[11,8],[8,10],[9,3],[3,4],[4,10]]);
    }else if(this.type == 2){
      idxsArray.push(...[[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3],[7,8],[9,10]]);
    }else if(this.type == 3){
      idxsArray.push(...[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]);
    }
    idxsArray.forEach((idxs) => {
      const i0 = idxs[0];
      const i1 = idxs[1];

      lineMarkers.push([
        { x: markers[i0].x, y: markers[i0].y, i: i0 },
        { x: markers[i1].x, y: markers[i1].y, i: i1 },
      ]);
    });
    
     return lineMarkers;
  }

  // API: Set speed
  setSpeed(speed = 1.0) {
    const freq = this.getFrequency();
    // avoid 0 divisor
    if (speed === 0) {
      speed += 0.001;
    }
    this.speed = this.clamp(this.minSpeed, this.maxSpeed, speed);

    this.init();
    let difffreq = freq / this.getFrequency();
    // avoid 0 divisor
    if (abs(difffreq) < 0.005) {
      difffreq += 0.01;
    }
    const t = this.tm.getTimer();
    this.starttime = t - (t - this.starttime) / difffreq;
    // console.log(freq, difffreq, t, this.starttime);
  }

  // API: Set parameters on walker
  setWalkerParam(bodyStructure, weight, nervousness, happiness) {
    const freq = this.getFrequency();

    // Body Structure Parameter
    if (bodyStructure !== undefined) {
      this.bodyStructure = this.clamp(this.minBodyStructure, this.maxBodyStructure, bodyStructure);
    }

    // Weight Parameter
    if (weight !== undefined) {
      this.weight = this.clamp(this.minWeight, this.maxWeight, weight);
    }

    // Nervousness Parameter
    if (nervousness !== undefined) {
      this.nervousness = this.clamp(this.minNervousness, this.maxNervousness, nervousness);
    }

    // Happiness Parameter
    if (happiness !== undefined) {
      this.happiness = this.clamp(this.minHappiness, this.maxHappiness, happiness);
    }

